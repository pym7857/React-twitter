ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
이 프로젝트는 antd는 3버전, next는 8버전을 써야 정상작동 
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
▶cd front -> npm run dev로 실행 ! 

▶npm init은 package.json을 만들어줌

▶Props: 부모->자식 유산

▶next: 
- SSR
- code splitting(500개 페이지 중 고객이 요청한 5개만 불러옴)(원래 react는 그냥 페이지 먼저 다 불러와버림)

▶
"scripts": {
    "dev": "next", // 빌드 -> npm run dev치면 서버실행 
    "build": "next build",
    "start": "next start" // 배포
  },

▶라우터 체계는 next의 강점입니다. (pages폴더만 만들면 됨)

▶{children} = props

▶react에서 style쓸때는 문자열로 쓰지말고 객체{}로 쓸것을 추천!

▶verticalAlign: 'middle' -> 상하 가운데 정렬 

▶(package.json)webpack의 dev -> react hot loader와 비슷. 새로고침 할 필요 X

▶리액트 = Hooks가 표준이 되었음.

▶value와 onChange는 짝꿍이다.

▶중복되는 로직의 훅 이벤트 처리.. -> '커스텀 훅'을 만들기

▶UseCallback : 함수 자체를 기억 

▶(signup.js)onChangePasswordCheck에 useCallback하는 이유 ? -> password가 setState되면 return 부분 전체 리렌더링 되버리기 때문

▶UseCallback(이벤트, dependencies:[])
-> dependencies에는 '지금 함수에서 쓰이는 변수' 넣어주기 

▶_app.js로 레이아웃 분리하기 
- pages폴더에 _app.js파일 추가 -> 이 파일이 pages폴더내의 다른 파일들의 부모컴포넌트가 된다. 
- 즉, 모든 파일에서 중복되는것들(head태그나 AppLayout.js등)을 여기에 넣어주면 된다

_app.js는 props를 { Component } 로 받는다. (Next에서 정해주는 이름)

▶setState될때마다 return() 부분 전체 리렌더링 됨.
즉, 회원가입 입력창에서 id부분 하나만 바꿔도 setState가 일어나기 때문에, return()부분의 폼에 해당하는 id,password입력창 전체가 리렌더링 됨

▶prop-types: props를 제대로 받았는지 확인 
(공식문서 참조)
ex)PropTypes.node:  node는 jsx에 들어갈 수 있는 모든 것(all)을 지칭 (=렌더링 될 수 있는 애들)

▶해결 
Q. AppLayout.js에 children이 들어가는 이유 !
A : _app.js는 모든 컴포넌트들의 부모이다. _app.js에서 <Component />로 자식들에게 Props를 보내고 있다. 이것을 AppLayout.js에서 { children }으로 받은것이다. 궁금하면 AppLayout.js에서 칠드런{children} 이라고 입력해보고 여러 탭으로 이동해보자. 각 탭의 화면이 {children}부분에 렌더링 될것이다.

▶xs : 모바일 / sm: 작은 화면 / md: 중간화면 / lg: 큰화면 
(=가로너비)
(=전체는 24)
(antd는 부트스트랩 처럼 '반응형'이다)

▶gutter={10} : xs, sm 등으로 분리한 화면의 간격을 넓혀주는 역할 

▶컴포넌트는 최대한 분리 ! (setState될때 리렌더링 되는거 방지)
-> But. 분리하면 할수록 부모자식 관계가 많이 생긴다. 
ex) AppLayout.js의 삼항연산자에서 LoginForm을 따로 분리한 이유 : LoginForm에 id 또는 password입력할때마다 return 전체 리렌더링 되버리기 때문 

▶자식컴포넌트에 값 넘기는 함수는 무조건 useCallback으로 감싸준다.
ex) LoginForm.js에서 <Form onSubmit={onSubmitForm}>

▶return ( <div style={{ }}></div> );

▶(profile.js) grid는 List아이템들간의 간격을 조정해주는 옵션 

▶배열안에 jsx쓸때는 전부 key를 넣어줘야 한다 !! 

▶컴포넌트를 분리하는 가장 쉬운 기준 : "리액트 반복문, 리액트 조건문, 폼"

▶Form은 state가 있기 때문에 왠만하면 분리해준다 

▶redux : 안정성, state통제 용이, Action기록으로 역추적 가능 
dummyData = { .. } 	-> ●Store(=redux state)
●Action -> state를 바꾸는 행동 
●Dispatch -> Action을 실행 
●Reducer -> Action의 결과로 state를 어떻게 바꿀지 미리 정의
( reducers/index.js 에서 reducer들을 하나로 묶어준다. )

▶
/* 
     Redux에서의 hooks문법 (@7.1이상 버전부터 가능)
     - useSelector(): hooks의 useState와 동일
     - dispatch(): useState안의 setState와 동일  
*/

▶Spread문법 (3dot)(=얕은복사) : 불변성 유지 위해서..
...state와 같이 새로운 객체를 참조하는 형식으로 만들어줘야 React에서 변화감지가능

* 불변성 이란 ?
React에서는 state는 불변성의 영역에있다. state를 바꾸기 위해서는 setState와 같은 문법으로만 바꿔야 한다.  

▶그냥 React에 redux 붙이는것과, Next에 redux붙이는게 조금 다름 ! 
(Next) npm i next-redux-wrapper 필요 ! 
①  (_app.js) const NodeBird = ({ Component, store }) => { ... 
<Provider store={store}> ... 를 보면,
이분에서 NodeBird에 store를 넣어줄 부분이 어디에도 없다 !! 
②  이 역할을 위의 패키지가 수행해준다. 
③  import withRedux from 'next-redux-wrapper';
④  (_app.js) export default withRedux()(NodeBird); // 고차 컴포넌트 : 기존 컴포넌트를 감싸줌으로써 기존 컴포넌트의 기능을 확장해준다 

▶redux의 기능을 확장할 땐 middlewares를 사용 
ex) _app.js에서 Redux_dev_tools설정하는 부분

▶"react-redux": "^7.1.0-alpha.4",
7.1부터 React redux hooks 사용가능 

▶action에 넣을 데이터가 동적인 경우에는 action을 '함수형태'로 만든다.
export const signUpAction = (data)  => {
...
}

▶회원가입 폼에서...
"리액트state와 리덕스state를 둘 다 만들어줘야 안귀찮다."
(사소한것들은 리액트state로 해버리자)
(리덕스state를 쓰면 모든것을 action을 통해 바꿔야 한다 -> 또, action하나당 reducer하나씩..)

▶폼은 보통 리액트 state로 만들고, 한방에 모아서 redux에 실어주는 방식이 더 좋음

▶redux는 모든게 '동기'. -> 바로바로 실행되기 때문에 특정 시간, 또는 특정 동작 이후에 액션을 실행할 수 없다.
-> redux middlewares를 써서 비동기 요청도 보내질 수 있게 하면된다.  
ex) redux saga 등등..

▶redux-saga
- 생소한 '제너레이터' 문법을 사용. ex) function* generator() {}
- 제너레이터는 함수 실행을 중간에 멈출 수 있고, 원할 때 재개할 수 있어 편리.
- reducer도 rootReducer가 있고, 그 밑에 여러 reducer들이 있었던 것처럼,
saga도 rootSaga가 있고, 그 밑에 여러 sage들이 있다.

▷redux-saga 버전으로 설치(Tip)
npm i redux-saga@1.0.2

▷VScode 글자 한번에 바꾸는법(Tip)
해당 글자 위에 커서 두고
ctrl + d 
계속 누르면 커서를 둔 글자랑 '똑같은 글자가 하나씩 드래그처리' 된다.
그리고 나서 값 입력할면 알아서 같은 글자 한번에 바뀜!

▶redux-saga
call : 함수 동기적 호출 
fork : 함수 비동기적 호출
put : dispatch와 동일 

▶redux는 LOG_IN이 바로 실행되버리기 때문에 서버 갔다올 틈 이 없다.
반면, redux-saga는 LOG_IN이라는 액션이 실행되는지 대기 -> 비동기 동작 -> 성공인지 실패인지 실행 

▶최종적으로 sagaMiddleware만들어서 _app.js의 middlewares=[]에다 붙이기 !

▶currying 기법
ex) 
hoc((Component))			// high order component
const hoc= (Component) => { ... }	// hook
 
ex)
connect(mapStateToProps)(Component)
const connect = (mapStateToProps) = (Component) => { ... }

▶ES2015 제너레이터 -> ※바탕화면 : [제너레이터]예제1~6 참고※
yield : 중단점
next : 재개 

▶사가 제너레이터
- 사가 미들웨어에서 알아서 next를 해줌 (적어줄 필요x)
- put({ type: 액션이름 }): redux의 dispatch와 같은 역할 
- take(액션이름): 해당 액션이 dispatch되면 제너레이터를 next하는 이벤트 (동기적 이벤트 리스너라고 생각하면 편함)
- all: 이벤트리스너가 여러개일때 하나로 묶어줌 
- 사가의 강점은 '반복문'으로 제어할 수 있다는 점이다. 
- 로그인에서는 거의 99% 제너레이터에 while(true)문을 쓴다. 

- while(true)를 숨길 수 있는 takeEvery, takeLatest 를 지원한다.
- takeEvery(액션이름, 그에따른 동작들)
- takeLatest(액션이름, 그에따른 동작들) : 동시에 여러번 같은게 들어오면 가장 마지막것만 유효하게 취급하겠다. (사용자가 로그인 버튼 여러번 광클)
- ex)  takeLatest(LOG_IN, login) // takeLatest가 LOG_IN 액션이 dispatch되길 기다려서 dispatch될 때, login 제너레이터를 호출합니다.

- call, fork는 둘다 함수를 실행해준다.
- call : 함수 동기적 호출 	ex)서버에 요청을 보내는 부분 
- fork : 함수 비동기적 호출	ex)액션간에 순서가 없는 경우에 붙힘(logger)
	-> 그냥 func() 로 불러도 되는데 의미명확히 하기위해 fork(func)

▶서버쪽에 갔다와야되는 비동기 액션들의 이름 규칙(3가지)
export const SIGN_UP_REQUEST = 'SIGN_UP_REQUEST';
export const SIGN_UP_SUCCESS = 'SIGN_UP_SUCCESS';
export const SIGN_UP_FAILURE = 'SIGN_UP_FAILURE';
-> 즉, 얘네는 리덕스(x) 리덕스-사가(o)에서 작업 

▶리덕스-사가 비동기 '패턴'(99% 이렇게 함) 
sagas/user.js의 구조 참조 

▶saga안쓰고 코드에서 바로 async await쓰는건 안좋은 건가요 ? (질문)
써도 되는데, 그렇게 해버리면 재사용성이 떨어져서 안좋음. 

▶airbnb 코드 룰 적용
> npm i -D eslint-config-airbnb@17.1.0
> npm i -D eslint-plugin-jsx-a11y@6.2.1	// 시각 장애인 용 
(.eslintrc)
"extends": [
        "airbnb"
    ],
"rules": {
        "no-underscore-dangle": "off"	// 경고 밑줄표시 off
        "react/forbid-prop-types": "off" // prop-types제한 off
    }
(eslint는 원래 정규 문법밖에 지원을 안함. 혹시 babel최신문법 쓰고싶다면..) "parser": "babel-eslint",
"env": {
	"es6" : true
}
airbnb Rule : ex) 상대경로로 임포트한 애들은 모듈보다 아래 있어야한다.

▶바로 return 하는 형식의 함수 만들기 
export const signUp = (data) => {	// 원래 함수
    return {
        type: SIGN_UP_REQUEST,
        data,
    };
}
export const signUp = data => ({   	// 바로 return하는 형식 
    type: SIGN_UP_REQUEST,
    data,
});

▶axios: "서버에 요청을 보내주는 모듈"

▶mainPosts: [dummyPost, ...state.mainPosts], 
// 뜻 : dummyPost가 기존에 있던 포스트들 앞에 들어가게 된다.

▶폼에는 무조건 e.preventDefault(); 붙힌다.

▶useEfferct 두번째 인자에는 왠만하면 객체 자체(me)를 넣지말고, 
객체안의 값(me.id)으로 넣어라.

useEffect(() => {
} [me && me.id]);	// 자바스크립트 객체는 undefined일 수 있으므로,
		// 항상 이렇게 가드를 해주자

▶리액트랑 제이쿼리랑 왠만하면 같이쓰면 안된다. 


========================== 백엔드==========================
▶npm run dev로 실행 !

npm i helmet hpp		// 노드,express의 보안 담당
npm i morgan		// 서버에 로그 남겨주는 애 
npm i multer		// 이미지 업로드 
npm i sequelize sequelize-cli	// ORM(Object-Relational Mapping)
			// SQL문이랑 자바스크립트랑 연결해주는것
npm i -D nodemon	// 변경사항 자동 반영 
npm i mysql2		// 얘도 시퀄라이즈랑 같이 깔아줘야됨 

▶(nodemon.json)
"watch"안에 있는것들 바뀌면, "exec" 다시 실행하겠다.

▶프론트와 백엔드간의 요청과 응답 : 규칙이 있어야됨 
REST API, GraphQL(=복잡)

▶GET, POST, PUT(=전체 수정), PATCH(=부분 수정), DELETE

▶npm i -g sequelize-cli 로 다시한번 설치해주기 
WHY?
-g를 붙여서 설치하면, cmd에 >sequelize와 같이 명령어를 줄 수 있다.

>sequelize init
db구성을 위한 폴더들을 알아서 만들어 줌 

▶DB설계 전에는 항상 ERD 그려보기 !
▶hasMany당한쪽은 belongsTo 만들어 주어야됨 
▶다대다 관계 (N:M관계) 는 belongsToMany 사용 !! (둘 다 해줘야됨)
▶다대다 관계는 중간에 테이블이 무조건 하나 생긴다 (through사용)

▶belongsToMany에는 왠만하면 as를 넣어주는게 나중에 편리하다
(나중에 as이름으로 해당되는것들을 가져온다)

▶Like
User한명이 여러Post에 좋아요 가능
Post하나에 여러User가 좋아요 가능 
-> 다대다 관계

[이해를 돕기위한 코드설명]
db.User.belongsToMany(db.Post, { through: 'Like', as: 'Liked' });
-> User에서 Post여러 갈래 = 좋아요 된 게시물들 = Liked
db.Post.belongsToMany(db.User, { through: 'Like', as: 'Likers' });
-> Post에서 User여러 갈래 = 좋아요 한 사람들 = Likers

▶yarn은 npm보다 나은점이 없다. 그래서 안씀 

▶config.json에서 정의했던 db를 생성한다.
> npx sequelize db:create 

▶Front에서는 import, export
Back에서는 require, module.exports 사용 !!! 

▶200: 성공
300: 리다이렉션
400: 요청 오류
500: 서버 오류
(400~599는 오류)

▶res.send('보낼 문자열') : 프론트로 문자열 보냄 
res.json(객체): 프론트로 JSON 데이터 보냄 
res.status(숫자): 프론트로 전송상태 보냄 

▶yield call(함수, 인자1, 인자2..)

▶app.use(미들웨어) : 요청과 응답 사이에서 요청과 응답을 변조
ex) app.use(morgan('dev')) : log남도록 변조

▶이제, body-parser 더이상 필요 X (express에서 지원함)
app.use(express.json());                            
app.use(express.urlencoded({ extended: true }));    

▶CORS에러(= Access-Control-Allow-Origin 에러)
localhost:3000(프론트) -> localhost:3065(서버)로 요청 보낼 수 없음 
▶서버쪽에서 cors처리 해줘야됨 
(서버 index.js) app.use(cors());

▶UseCallback에서 쓰이는 변수들은 모두 []안에 적어주어야됨 !! (까먹지X)

▶select * from `react-nodebird`.users; (백틱 인것에 주의 !)

▶로그인같은 정보는 민감한것이기 때문에 서버에 저장을 한다. 
프론트에서는 유저가 로그인 한지 안한지 모른다. 

그러나 프론트에도 로그인 기록을 남겨놔야 한다. 
이것을 알기 위해서 서버쪽에서 인증을 받아와야한다. 
이 인증을 보통 `쿠키`로 받아온다. 
(쿠키: 서버->프론트로 보내는것). 
(서버쪽에서는 세션에 로그인한 사용자의 정보를 넣어줘야한다.)

즉, 사용자 정보는 서버의 세션에, 
프론트에는 세션을 조회할 수 있는 '쿠키'를 전달 

▶쿠키값은 모두 암호화를 해줘야한다. 

▶expressSession객체에는 옵션을 무조건 명시해줘야 한다. 
app.use(expressSession({
    resave: false,		// resave: 매번 세션 강제 저장 
    saveUninitialized: false,	// saveUninitialized: 빈 값도 저장
    secret: process.env.COOKIE_SECRET, // 쿠키 암호화 (.env에 저장되있음)
    cookie: {
        httpOnly: true,	// 쿠키를 자바스크립트에서 접근 불가
        secure: false,		// https를 쓸때만 true로 설정해주자  
    },
}));

▶config.json을 config.js 로 바꿔서 DB_PASSWORD변수를 쓸 수 있게 하자.

▶서버쪽에 매번 세션붙여주고, 프론트에 매번 쿠키붙여주고, 매번 지금 로그인한 사용자가 누구인지 찾기 힘들기 때문에, 
이를 자동화 해주는 passport 모듈을 사용하자. 

▶▶passport 사용법 
사용자 한명에 대한 정보는 양이 방대함. 이를 서버쪽 메모리에 모두 저장하면 안됨. (서버 메모리 터짐)
mysql에서는 userId말고도 고유 id(user.id)들을 하나씩 부여 해준다.
■serializeUser: 서버쪽에 [{ id: 3, cookie: 'aaaa' }] 이런식으로 유저 대표 정보를 저장한다. (메모리 절약)
-> return done(null, user.id);
-> 서버쪽에서는 쿠키와 연관된 id를 찾게된다.
■deserializeUser: id를 (db를 불러와서) deserialize해서 유저 정보를 되찾는다. 
-> return done(null, user);	// 불러온 유저정보는 req.user에 저장된다. 

즉, serializeUser는 사용자 정보 객체를 세션에 아이디로 저장하는것이고,
deserializeUser는 세션에 저장한 아이디를 통해, 사용자 정보 객체를 불러오는것


▶JWT 안쓰는 이유
JWT가 그렇게 좋지는 않음. 대부분의 경우는 쿠키와 세션으로 하는게 맞음.
JWT를 쓰려면 진짜 대규모 여야됨.
JWT는 단점이 많음. 

▶done(서버에러, 성공객체(실패시 false), 실패시 사유)

▶▶ passport 과정 ★
1) passport/local.js는 module.exports로 passport/index.js에 붙힌다. 
2) passport/index.js는 back/index.js(중앙 통제실)에 붙힌다.  
3) passport연결은 했지만, 실제 프론트 -> 백으로 로그인 요청은 router.post('/login' ...)이곳에 보내게 된다. 
4) 여기서 바로 전략을 실행해주면 되는것이다.
5) back/routes/user.js의 router.post('/login' ...)부분에 
passport.authenticate('local', (err, user, info) => { ... 
를 붙혀주면 전략부분 실행되게 된다. 이때, back/passport/local.js의 로직을 실행한다. 
6) 그 결과를 err, user,info에 담아온다.
** [err, user, info] 는 done의 [첫번째, 두번째, 세번째 인자]
7) authenticate함수의 예외처리 통과했다면, 최종적으로 프론트로 로그인된 유저 정보 보내준다. 
-> return req.login(user, ...)
8) authenticate함수의 return req.login을 할때, serializeUser가 실행되도록 애초에 그렇게 설계되어있다. (=사용자 정보객체를 '세션'에 저장)
(=로그인한 유저의 {id와 cookie}만 백쪽에서 간직하게 된다 -> 가벼움)
9) 앞으로는 프론트에서 cookie를 보내는 요청을 하면, 백에서cookieParser로 쿠키 검사후, id:3 발견 -> id: 3를 이용해서, deserializeUser에서 사용자 정보 객체( req.user)를 불러와서 사용.

** 프론트에서 백으로는 cookie만 보낸다.
** 요청 보낼때마다 deserializeUser가 실행된다 !!
(But. db한번씩 꼭 다녀와야됨. db갔다오는게 서버비용 제일 비쌈.)
(그래서 실무에서는 결과를 캐싱)

▶Tip. POST메서드 썼다고해도 https 적용안하면 비밀번호 network창에 노출됨 

▶현재 로그인해도, 쿠키가 없다. (프론트와 백이 도메인이 달라서 생기는 현상)
그래서 새로고침하면 로그인 풀려버린다. 
-> F12의 쿠키 한번 확인 해보기 

▶▶ 다른 도메인간에 쿠키 주고 받기 설정 ★(프론트, 백 둘다 설정 해줘야됨)
■프론트 쪽 설정
function loginAPI(loginData) {   // 서버에 요청을 보내는 부분 
    return axios.post('/user/login', loginData, {
        withCredentials: true,
    }); 
}
axios.post의 세번째 인자에 withCredentials: true해줘야 서로 쿠키를 주고받을 수 있음. 

■백 쪽 설정
app.use(cors({
    origin: 'http://localhost:3000',  // 또는 origin: true (=요청 주소와 같게 설정)
    credentials: true,
}));
이렇게 두개 설정 해줘야 서로 쿠키를 주고받을 수 있음. 

■결과 확인 
로그인 하고, Network탭의 login 부분의 Response Header에서..
Access-Control-Allow-Credentials: true
Access-Control-Allow-Origin: 'http://localhost:3000'
이렇게 나와야 성공 


▶▶ 그러나 지금도 로그인 하고, 새로고침하면 풀려버림.
WHY?
"쿠키는 남아있는데", 처음 로딩할때 서버로부터 사용자 데이터 받는 부분이 없음

▷Tip. Express쓸때는 쿠키 이름이 전부 connect.sid
-> 해커들이 이걸보고 Express 쓰는걸 알고, Express취약점으로 공격할 수 있음
-> 쿠키이름 바꿔주자  
app.use(expressSession({
    resave: false,
    saveUninitialized: false,
    secret: process.env.COOKIE_SECRET,
    cookie: {
        httpOnly: true,
        secure: false,
    },
    name: 'abcd',		// 이렇게 하면, 앞으로 로그인할때 쿠키이름abcd
}));

(과정1)
■front/sagas/user.js
function loginAPI(loginData) {   // 서버에 요청을 보내는 부분 
    return axios.post('/user/login', loginData, {
        withCredentials: true,
    }); 
}
function* login(action) {
    try {
        const result = yield call(loginAPI, action.data); 
        yield put({     
            type: LOG_IN_SUCCESS,
            data: result.data, 		// axios응답(result)은 응답객체.data안에 들어있다. 
        });
    } catch (e) {
        console.error(e);
        yield put({
            type: LOG_IN_FAILURE,
        });
    }
}
(과정2)
■front/reducers/user.js
case LOG_IN_SUCCESS: {
            return {
                ...state,
                isLoggingIn: false,
                isLoggedIn: true,
                me: action.data,		// 여기서 me에 fullUser들어감
                isLoading: false,
            };
        }



▶▶ 이제 드디어, 처음 로딩할때 서버로부터 사용자 정보 받아오기를 해보자. 
(현재 쿠키만 있는 상황이어서 로그인 새로고침하면 로그아웃 되버림)
■front/sagas/user.js
function* userSaga() {
    yield all([
        fork(watchLogin),
        fork(watchLogout),
        fork(watchLoadUser),	// 사용자 정보 받아오는것 
        fork(watchSignUp),
    ]);
}

▶LOAD_USER_REQUEST는 모든 페이지에서 불러와야됨 
■front/components/AppLayout.js 	(프론트)
useEffect(() => {
    if (!me) {  // 내 정보 없다면 
      dispatch({
        type: LOAD_USER_REQUEST,  // 내 정보 불러오기 ( 쿠키를 이용하여.. -> sagas/user.js의 loadUserAPI() 참조 )
                                  // 로그인을 안한 상태면, 쿠키도 없을테니 LOAD_USER_REQUEST 불가 
      })
    }
  }, []); // ComponentDidMount

■back/routes/user.js 		(백엔드)
router.get('/', (req, res) => {
    if (!req.user) {  // deserializaUser가 req.user 생성 
      return res.status(401).send('로그인이 필요합니다.');
    }
    return res.json(req.user);
});

▶Tip. 서버 재시작하면 로그인이 풀려버림.
Why? 아까 백쪽에 { id: 3, cookie: "abcd" }를 백쪽 메모리에 저장해뒀었음. (=가벼움)
서버를 재시작하면 메모리가 날라가버린다.
But. 실무에서는 서버 재시작해도 다 날라가지 않음.
Why? 사용자 정보 세션을 모아놓은 DB를 따로 설계. 보통은 Redis를 많이 사용 

▶일단, 지금 me.posts.length가 0이라서 length undefined 오류 뜸 (UserProfile.js)
return (
        <Card     
            actions={[
                <div key="twit">게시글<br />{}</div>,            // 나중에 me.posts.length로 바꿔
                <div key="following">팔로잉<br />{}</div>,
                <div key="follower">팔로워<br />{}</div>,
            ]}
        >

▶Node에서는 한번 불러온 모듈은 캐싱이 된다. 
(즉, 한곳에서 모듈 설정하면 해당 모듈 import한 다른곳에도 적용됨)

▶res.json()으로 보내기 전에 어떨떄는 toJSON을 붙히고 어떨떄는 안붙히는 것인지?
ex) db에서 가져온 객체를 수정할때 -> toJSON을 붙힌다. 
    const user = Object.assign({}, req.user.toJSON()); 	// toJSON()먼저 하고, 
    delete user.password;                               	// 비밀번호 지우고 정보 보내기 
    return res.json(user);

ex) 객체를 수정하지 않을때는 그냥 보낸다.  
     const posts = await db.Post.findAll({});
     res.json(posts);

▶정규표현식 테스트 할 수 있는 웹사이트 : regexr.com


▶▶ (6-1)해시태그 링크로 만들기. <- 어려운 부분. 스스로 새로운거 만들어보지 않으면 실력늘지X

 ■(PostCard.js)
<Card.Meta
          avatar={<Avatar>{post.User.nickname[0]}</Avatar>}
          title={post.User.nickname}
          description={post.content}	// 이부분을 description={<div>{post.content}</div>}
/>

 ■a tag만 사용하는것이 아니라, Next의 <Link>태그를 사용해야 SPA가 유지됨 

 ■description={(
            <div>
              {post.content.split(/(#[^\s]+)/g).map((v) => {
                if (v.match(/#[^\s]+/g)) {	  // 쪼개진 애가 해시태그면, 링크로 바꿔주기
                  return (
                    <Link href="/hashtag" key={v}><a>{v}</a></Link>
                  );
                }
                return v; // 해시태그(#)가 아니라면, 그냥 문자열만 리턴 
              })}
            </div>
)}

 ■설명 
inputString = '#구독 #좋아요 눌러주세요. #유튜브'
inputString .split(/#[^\s]+/g)
	▶결과: ["", " ", " 눌러주세요. ", ""]	-> 해시태그 제외한 결과나옴

inputString = '#구독 #좋아요 눌러주세요. #유튜브'
inputString .split(/(#[^\s]+)/g)	-> 그룹()으로 묶으면..
	▶결과: ["", "#구독", " ", "#좋아요",  " 눌러주세요. ", "#유튜브", ""]	-> 해시태그  포함된 결과 나옴


▶▶ #좋아요 누르면 localhost:3000/hashtag/좋아요 페이지로 이동해야한다
But. Next는 동적 주소를 처리하지 못합니다. 
-> (hashtag주소가 수십만 가지인데, 그 page들을 전부 만들어 줄 수 없다)
-> Next말고 Express를 사용하면 된다. Express도 프론트에 연결 해주자. 

-> Next서버랑 Express서버가 동시에 돌아가는게 아니라, Next와 Express가 이어진다.
-> Express가 돌아가는데, Express가 Next를 그 안에서 돌린다 !!
-> ( Express는 개발환경에서는 nodemon으로 돌아간다 )
■(package.json)
"scripts": {
    "dev": "nodemon",	// 여기가 이제 "next"가 아니라, "nodemon"이다. 
    "build": "next build",
    "start": "next start"
  }, 

■server.js 작성 (express와 next를 연결해주는 코드 작성)

■nodemon.json 작성
{
    "watch": [
        "server.js",
        "nodemon.json"
    ],
    "exec": "node server.js",
    "ext": "js json jsx"
}

▶프론트에서가 아니라, 서버(백)쪽에서 saga를 돌리는게 서버사이드 렌더링(SSR)이다. 

▶▶ Next + Express로 동적페이지 처리하는 기법 (과정) ★
[과정 1]. front/pages폴더에 hashtag.js, user.js 만든다.
[과정 2].  
■이 부분은 Next에서 실행시켜주는 부분이고, context도 같이 넣어줍니다 !!!!!
(_app.js)
NodeBird.getInitialProps = async (context) => {	
    console.log(context);		    // 이거 찍어보기 (Component, ctx 등등 있음..)
    const { ctx, Component } = context;   // Component는 각 페이지들이었음. (NodeBird가 Props로 받은것이었음)
    let pageProps = {};
    if (Component.getInitialProps) {	    // ■Component각각에 getInitialProps가 있으면 실행을 해주겠다는 뜻  
        pageProps = await Component.getInitialProps(ctx);	  // _app.js의 (context.ctx)를,
						  // 각 컴포넌트에서는 (context)로 받는다. 
    } 
    return { pageProps };
};
[과정 3]. (front/server.js)
server.get('/hashtag/:tag', (req, res) => {
        return app.render(req, res, '/hashtag', 	// GET요청시, pages/hashtag.js 를 렌더링 (동적 주소 처리 가능)
	{ tag: req.params.tag });    		// ■서버에서 이렇게, query {}를 같이 전달해줘야 
					// ■프론트에서 동적인 tag를 캐치 가능
});
[과정 4]. (pages/hashtag.js)
■Hashtag.getInitialProps는 (_app.js에서 설정을 해놨기 때문에) 실행이 가능하다. 
Hashtag.getInitialProps = async (context) => {	// _app.js의 (ctx) -> Hashtag.getInitialProps에서 (context)로 받는다. 
    console.log(context)			// ■ query: { tag: '가위바위보' }, 
    console.log(context.query.tag);
    return { tag: context.query.tag };		// ■return 값이 (_app.js)NodeBird.getInitialProps의 pageProps에 담긴다
};

[과정 5]. (_app.js)
NodeBird.getInitialProps = async (context) => {	
    ...
    if (Component.getInitialProps) {	
        pageProps = await Component.getInitialProps(ctx);	// 여기에 담긴다. 
    } 
    return { pageProps };	// ■이것을 다시 NodeBird의 props로 넘긴다. 
};

[과정 6]. (_app.js)
const NodeBird = ({ Component, store, pageProps }) => {   // pageProps로 받고,
    return (
	...
            <AppLayout>
                <Component {...pageProps}/>	// ■각 컴포넌트에 props로 넘긴다. 
            </AppLayout>
        	...
    );
};

[과정 7]. (hashtag.js)
const Hashtag = ({ tag }) => {	// ■최종적으로 여기서 쓸 수 있다. 
    return (
        <div>Hashtag {tag}</div>
    );
};

■정리
- Hashtag.getInitialProps는 (_app.js에서 설정을 해놨기 때문에) 실행이 가능하다. 
- server에서 { tag: req.params.tag }로 전달한것을, Hashtag.getInitialProps에서 context.query.tag로 받을 수 있다. 

Tip)
- getInitialProps는 ComponentDidMount보다도 빨리 실행된다. (가장 먼저 실행된다)
- getInitialProps는 서버로부터 데이터를 받아오는 역할이다. 



▶어떻게 Post.User라는게 가능한것인가 ? (routes/post.js 의 [게시글작성 라우터] 참조!) ★★

/* 게시글을 프론트로 보내기 */
        /* 방법1: sequelize에서 제공하는 get 메서드 사용하기 */
        const User = await newPost.getUser();   	// 게시글과 연관된 사용자만 가져온다. 
					// (=게시글과 연관된 사용자는 글쓴이 딱 한명이다.)
        newPost.User = User;                    	// Post에 User라는 속성을 달아줌.
                                                	// -> (PostCard.js) post.User.nickname[0].. 이런식으로 사용가능 !! 
        res.json(newPost);

        /* 방법2: db에서 불러와서 프론트로 전달 */
        const fullPost = await db.Post.findOne({
            where: { id: newPost.id },
            include: [{
                model: db.User, // 게시글과 연관된 사용자만 가져온다. (=게시글과 연관된 사용자는 글쓴이 딱 한명이다.)
                                	 // include를 이렇게 '명시'해주면, Post에 User라는 속성을 달아줌.
                                	 // -> (PostCard.js) post.User.nickname[0].. 이런식으로 사용가능 !!
            }],
        });
        res.json(fullPost);

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ시작ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
▶Link 태그의 href는 [프론트엔드 서버]가 처리합니다. ★★
즉, 프론트엔드의 server.js에서 처리합니다.

(PostCard.js)
<Link href={`/hashtag/${v.slice(1)}`} key={v}><a>{v}</a></Link>

(server.js)
server.get('/hashtag/:tag', (req, res) => {
        return app.render(req, res, '/hashtag', { tag: req.params.tag });    // pages/hashtag.js 를 렌더링
                                                                             	     // {}를 같이 전달해줘야 프론트에서 동적인 tag를 캐치 가능
});

▶문제 : 현재, Link 클릭하면 페이지가 새로고침 되버린다. -> SPA에 위배된다.
해결 : Link부분을 수정해줘야 된다. 

(현재 Link형식)
<Link href={`/hashtag/${v.slice(1)}`} key={v}><a>{v}</a></Link> 
-> 현재 이부분은 동적주소이기 때문에 프론트에서 처리를 못하고 Express서버로 넘어가 버린다. 
-> (위에서 언급했듯이 server.js로 가버린다.) 
-> Link부분을 프론트에서 처리할 수 있게 바꿔줘야 된다. 
-> Link를 객체 형식으로 바꿔주자 

■객체형식의 Link로 수정 (=동적인 router의 Link사용법)
<Link 
	href={{ pathname: '/hashtag', query: { tag: v.slice(1) } }} 
	key={v}
>
<a>{v}</a>
</Link>

Tip)
이제, 링크 누르면 http://localhost:3060/hashtag?tag=좋아요  라고 뜬다.
그러나, http://localhost:3060/hashtag/좋아요 와 같은 형식의 url을 얻길 원한다면, Link속성에 as를 추가해주자. ★
	    <Link 
                    href={{ pathname: '/hashtag', query: { tag: v.slice(1) } }} 	// 내부적으로는 이렇게
                    as={`/hashtag/${v.slice(1)}`}				// 외부적으로는 이렇게
                    key={v}						
                >
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ끝ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ


▶사용자가 댓글 볼지 안볼지 모름. 게시글과 댓글 같이 가져오는것은 데이터 낭비
-> 게시글 가져오기, 댓글 가져오기는 액션을 따로 만들어 주자. 

▶항상 catch 부분에는 console.error(e) 달아주기 !! - 디버깅 할때 엄청 편해짐 

▶ 미들웨어 중복 제거하기 
if (!req.user) {
            return res.status(401).send('게시글을 작성하려면 로그인이 필요합니다.');
}
와 같이 로그인했는지 검사하는 부분이 여러곳에서 중복되므로, 중복제거 해주자.

→ routes/middleware.js 생성&작성 
exports.isLoggedIn = (req, res, next) => {
    if (req.user) {
        next();     // next()를 하면 다음 미들웨어로 ! 
    } else {
        res.status(401).send('로그인이 필요합니다.')
    }
}

→ 이제 다른 라우터에서 isLoggedIn 불러와서 삽입  
const { isLoggedIn } = require('./middleware');

router.post('/', isLoggedIn, async (req, res, next) => { ... }		// 매개변수 순서대로 진행됨 

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ시작ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
▶▶ 이미지 업로드 프론트 구현하기 
■ 과정 (1)
import React, { useRef } from 'react';
const imageInput = useRef();
...

<Form encType="multipart/form-data" onSubmit={onSubmitForm} >	// multipart/form-data로 Form태그 작성 
	...
	<input type="file" multiple hidden ref={imageInput} onChange={onChangeImages}/>
	<Button onClick={onClickImageUpload}>이미지 업로드</Button>

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
useMemo() : 함수의 리턴값을 기억
useCallback() : 함수 자체를 기억
useRef() : 일반 값을 기억  
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
■ 과정 (2)
const onClickImageUpload = useCallback(() => {
      imageInput.current.click();   // 이미지업로드Button을 눌렀을때, input type="file"을 누른 효과가 나게 된다.★
}, []);

■ 과정 (3)
▶SPA를 유지하기 위해서는, multipart/form-data를 submit눌러서 바로 보내는것이 아닌, "AJAX"로 보낸다. ★
const onChangeImages = useCallback((e) => {
      console.log(e.target.files); 
      const imageFormData = new FormData();   // AJAX를 위해서 FormData라는 객체안에 일일히 파일 정보 담아준다. 
	... append()...   

      dispatch({
        type: UPLOAD_IMAGES_REQUEST,
        data: imageFormData,
      });
}, []);
▶실무에서는 이미지 따로, 게시글 따로 업로드 (같이 보내면 편하긴 한데, 나중에 안좋아짐)

■ 과정 (4)
▶FormData '파일'은 body.parser로 처리할 수 없음. -> multer라는 미들웨어 사용 ! (=이미지,동영상 파일 다 됨)
(routes/post.js)
◇[순서 1] const multer = require('multer');
◇[순서 2] const upload = multer( { 옵션 ... } )     // multer에 대한 옵션을 작성 
◇[순서 3] 이미지 업로드 라우터 작성 
router.post('/images', upload.array('image'), (req, res) => {
    console.log(req.files);
    res.json(req.files.map(v => v.filename));  // 파일이름 담겨서 감
});
◇[순서 4] 
(sagas/post.js)
function* uploadImages(action) {
    try {
      const result = yield call(uploadImagesAPI, action.data);	// result에는 파일이름.png 담김 
      yield put({
        type: UPLOAD_IMAGES_SUCCESS,
        data: result.data,
      });

(reducers/post.js)
case UPLOAD_IMAGES_SUCCESS: {
            return {
              ...state,
              imagePaths: [...state.imagePaths, ...action.data],    	// imagePaths: 이미지 미리보기 경로 
							// 기존 imagePaths배열에 action.data 추가 
            };
}

▶But. 현재, '서버쪽에서 upload한 이미지'를 가져오는 부분이 제대로 되지않는다. (프론트 화면 확인해볼것)
-> uploads폴더안의 파일을 가져와야한다. 
-> 프론트에서 백 폴더안의 파일을 어떻게 가져옴? 
-> 이것은 express의 static 미들웨어로 해결가능 ★
(back/index.js)
app.use('/', express.static('uploads'));  	// 서버쪽의 'uploads'폴더를 다른서버에서 '/'로 접근 가능하도록 

(PostForm.js)
{imagePaths.map((v, i) => { ...
	...
	<img src={`http://localhost:3065/${v}`}		-> 이제, '/'로 GET요청 가능해짐
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ끝ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

▶setState는 비동기이다. (제로초 인프런 내 질문글 다시보기)


▶Q.  [].forEach.call 은 어떤 의미일까? - 인프런 내 질문 글 답변 (6.8장 Q&A)
(PostForm.js)
const imageFormData = new FormData();
[].forEach.call(e.target.files, (f) => {
        imageFormData.append('image', f); 
});
▶e.target.files는 유사배열이다.
(제로초 블로그 글: https://www.zerocho.com/category/JavaScript/post/5af6f9e707d77a001bb579d2)
[].forEach.call( 유사배열, (원소) => { .. } )

▶배열을 map으로 하고, Promise.all하면 DB의 작업들이 한방에 처리됨.
const images = await Promise.all(req.body.images.map((image) => {
         return db.Image.create({ src: image });
}));

▶antd <Card> 태그의 cover라는 속성으로, 이미지를 <Card>에 가져올 수 있다. 
<Card
        key={+post.createdAt}
        cover={post.Images[0] && <PostImages images={post.Images} />}
        ...
...
>
▶제로초 질문 Q&A
Q.  post.Images 는 어떻게 탄생된걸까 ? - 인프런 내 질문 글 (6.12장 Q&A)
1. add()한건 연결만 한 것이고, post.Images는 include image를 했기때문에 불러올 수 있었습니다. ★ 
	-> include를 쓰려면 add 메서드로 먼저 관계를 추가해 주어야 한다. ★
	-> include는 get과 같은 역할. get을 하기 위해서는 add가 되어있어야 합니다. ★
	-> add: 관계 설정, set: 관계 수정, remove: 관계 제거, get: 관계 조회 (=include와 동일) ★ 
2번 답도 되었네요. include가 객체로 만드는 역할입니다.
3번은 다대다나 1대다 관계에서는 단수형 복수형이 둘다 만들어집니다. 1대1관계에서는 복수형이 없겠죠?
ex) addLiker(), addLikers()

▶제로초 질문 Q&A
await post.addLiker() 라고 했는데 왜 post.Likers로 사용이 가능할까?  - 인프런 내 질문 글 (6.14장 Q&A)
다대다 관계여서 Likers(복수)로 씁니다. add할때 정해지는게 아니라 associate할때 이미 정해져 있습니다.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ시작ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
▶▶ 이미지 슬라이더 - React에서 제공하는 Slick 사용!! 
■import Slick from 'react-slick';
■<Slick>안에 map같은 반복문으로 <div></div> 구역처리 해놓으면, 이게 알아서 슬라이드로 됨. 
■<Slick>에 옵션 설정해놔야 제대로 작동

■이제, [이미지 클릭 -> 이미지 확대됨 -> Slick을 이용해서 슬라이더로 구현] 하는 작업을 해보자. 

■ImagesZoom부분에 CSS따로 설정해줘야 Slick창이 예쁘게 뜸 
■But. 현재 적용한 CSS가 제대로 작동하지 않는다. 
해결))
<link rel="stylesheet" type="text/css" 
charSet="UTF-8" href="https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.6.0/slick.min.css" />
<link rel="stylesheet" type="text/css" 
href="https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.6.0/slick-theme.min.css" />

>> front/pages/_app.js에 위 링크 두개 추가해줘야 <Slick>에 적용한 CSS가 제대로 작동 (=공식 문서)
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ끝ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

▶spread 에러 -> 실제로 그 객체가 존재해야 Error가 나지 않는다. 

▶include로 자동으로 가져오는것을 SQL로 짜려면 엄청 힘들다.
include를 남용하면 성능저하가 일어나게 된다. 

▶reducer의 단점
ex) post reducer에서 일어나는 일들은 post reducer안의 데이터들만 조작이 가능하다. 

게시글 작성 -> post reducer
But. 본인이 쓴 게시글 개수는 -> user reducer안에 들어있다. 

-> 해결: saga에서 action을 두개 호출
function* addPost(action) {
    try {
        const result = yield call(addPostAPI, action.data);
        yield put({				// post reducer의 데이터를 수정
            type: ADD_POST_SUCCESS,
            data: result.data,
        });
        yield put({				// user reducer의 데이터를 수정
          type: ADD_POST_TO_ME,
          data: result.data.id,
        })

▶useEffect에 본인이 아닌경우, 메인페이지로 되돌리는 작업
-> 아직 SSR을 적용안했기 때문에 불가능. 

▶anonymous(404)에러 + 갑자기 아무 기능도 안되는 에러
- 현상 : '팔로워 삭제' 누를때, REQUEST만 가고 SUCCESS인지 FAILURE인지 응답이 오지 않음 !!
- 에러발생: anonymous에러(404) + 갑자기 아무 기능도 안되는 에러
	>> 모든 기능이 다 망가져 버림 
해결))
reducers/user.js에 REMOVE_FOLLOWER_REQUEST만 import되어있고, 
REMOVE_FOLLOWER_FAILURE, REMOVE_FOLLOWER_SUCCESS는 import 되어있지 않았음 

▶상단 페이지 진행 바 ?

▶6-20장 제로초 질문: 댓글 가져오기 할때 로그인 했는데 로그인 하라고 함
-> 원인: router에서 isLoggedIn이 쓰이는데, saga에서 axios 요청할때 withCredentials:true 를 해주지 않았다 !!!
-> 해결: 그냥 router에서 isLoggedIn을 없앴다. 

▶에러 : Cannot read property OOO of null 에러 
▶해결 : 객체에 점(.) 찍힐 때는 객체가 있나 없나 체크하는게 중요 
(me && me.nickname)
ex) <Input addonBefore="닉네임" value={editedName || (me && me.nickname)} onChange={onChangeNickname}/>

(post.Images && post.Images[0])
ex) cover={post.Images && post.Images[0] && <PostImages images={post.Images} />}



==========================SSR (서버사이드 렌더링)==========================
▶현재: 로그인 한 후에, 새로고침하면 잠깐동안 로그인 풀린 화면이 보인다. 
▶SSR로 해결가능 !

▶서비스가 검색엔진에 노출되야됨
▶검색봇이 사이트 스캔 -> SPA는 로딩후에 데이터 불러오기 때문에 처음에는 텅 비어있음 -> 기다리지 않고 가버림
▶구글은 알아서 잘 가져가지만, naver검색엔진은 그렇지X

▶postman으로 GET요청 보내보기 -> 게시글들이 텅 비어있는것을 확인할 수 있다.

▶Next를 쓰는 가장 큰 이유가 SSR 때문이었음.

▶Next의 getInitialProps가 SSR의 가장 핵심 !★
getInitialProps:  페이지 불러올때, 서버쪽에서 최초 한번 실행
		 -> 이후, 프론트에서 next(); 로 라우터 넘나들때는 프론트에서 계속 실행

▶즉, 페이지 로딩될때, getInitialProps가 서버쪽을 먼저 거치기 때문에,
User.getInitialProps = async (context) => {
    					// 여기서 서버로부터 데이터를 받아올 수 있다. (axios나 redux-saga이용)
    return { id: parseInt(context.query.id, 10) };
};



▶▶ ( pages/index.js 부터 작업 시작 ! )
▶[순서1] 
useEffect(() => {			
    dispatch({
      type: LOAD_MAIN_POSTS_REQUEST,	// 이런것들을 전부 getInitialProps로 옮기자 ! 
    });
  }, []); // ComponentDidMount

▶[순서2] useEffect()를 주석처리 한 후,
Home.getInitialProps = async (context) => {   // _app.js의 (context.ctx)를 각 컴포넌트에서는 (context)로 받는다.
  console.log(Object.keys(context));  	          // ['err','req','res','pathname','query','asPath','store','isServer']
                                      	          // 이 중에, 'store'가 redux store이다. 
				          // 이 store안에는 dispatch(), getState()가 들어있다. ★
  context.store.dispatch({
    type: LOAD_MAIN_POSTS_REQUEST,
  });
};

▶[순서3] 그러나, 현재 메인페이지에 아무것도 안불러와짐 -> _app.js에서 saga에 대한 설정을 하나 더 해줘야한다. 
(_app.js)
■import withReduxSaga from 'next-redux-saga';		// next용 redux-saga 
							// 이게 있어야 next서버에서 redux-saga를 돌릴 수 O

■ > npm i next-redux-saga@4.0.2			

■export default withRedux(configureStore)(withReduxSaga(NodeBird));	// withReduxSaga로 감싸주자 

■
const configureStore = (...) => {
   ...
   store.sagaTask = sagaMiddleware.run(rootSaga);   		// store.sagaTask를 withReduxSaga가 필요로 함. 
   return store;
};

▶이제 메인페이지 새로고침 해보면, 게시글들이 미리 불러와져 있는것을 확인할 수 있다. 
(But.로그인은 여전히 풀려있다 -> 아직 작업해주지 않았기 때문)
▶이제, postman으로 GET요청 다시 보내보면.. -> 이제 게시글들이 보인다 ! 




▶▶ 다른페이지들도 SSR을 적용시켜 보자. -> getInitialProps를 pages폴더안에 있는것들에만 써야한다 ! ★
1. AppLayout.js
-> pages폴더안에 들어있는 파일이 아니다. 
-> _app.js의 NodeBird.getInitailProps 안에, AppLayout.js의 dispatch를 적어주자. 

(AppLayout.js)
useEffect(() => {
    if (!me) {  // 내 정보 없다면 	-> 이 부분도 흉내내줄 수 있다. 
      dispatch({
        type: LOAD_USER_REQUEST,  
      });
    }
  }, []);


(_app.js)
NodeBird.getInitialProps = async (context) ...
   ...
   /* 내 정보 먼저 가져온 후에, */
    const state = ctx.store.getState();		-> ctx.store의 getState()를 이용 ! 
    if (!state.user.me) {
        ctx.store.dispatch({
            type: LOAD_USER_REQUEST,
        });
    }

    /* 다른 컴포넌트들을 호출한다. */
   ...

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ시작ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
▶▶ 위의 LOAD_USER_REQUEST할때, SSR을 위해 쿠키 넣어주기
ex)
function likePostAPI(postId) {
    return axios.post(`/post/${postId}/like`, {}, {     
      withCredentials: true,			// 클라이언트에서 요청 보낼때는,
					// 브라우저(=클라이언트)가 쿠키를 같이 동봉해줘요.
    });
}
					// 그러나, SSR 일때는, 브라우저가 없어요.(=쿠키를 전달해줄 수 없어요)
					// SSR일떄는, 우리가 직접 쿠키 넣어줘야 한다. 
■ getInitialProps는 서버,프론트 둘다 에서 일어난다.
-> 쿠키 보낼때는 서버환경인지 체크하고, 서버환경일떄만 axios.defaults에 cookie넣어주면 된다. 

■ (_app.js)
NodeBird.getInitialProps = async (context) ...
	/* SSR일때는, 우리가 직접 cookie 넣어줘야 한다. */
    	const cookie = ctx.isServer ? ctx.req.headers.cookie : '';          // 서버환경일때, 
							       // ctx.req.headers안에 cookie 가 들어있다.
    	/* 서버 환경이고, cookie가 존재할때만 아래 작업 실행 */
    	if (ctx.isServer && cookie) {
        		axios.defaults.headers.Cookie = cookie;     // axios에 cookie 데이터를 기본으로 심어준다. 
						      // (SSR일때는 브라우저(=클라이언트)가 없기 때문에, 
						      // 프론트'서버'-> 백 으로 쿠키 보내는 방법)
                                                    		      // axios.defaults 해주면 모든 axios에 적용이 된다. 
    	}
    	/* 내 정보 먼저 가져온 후에, */
	...
■ 이제, 메인페이지 새로고침하면, 로그인된 부분 바로 받아온다 ~! (=성공)
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ끝ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ


■http://localhost:3061/hashtag?tag=리액트	-> 여기에도 SSR 적용시켜 보자.
(pages/hashtag.js)
... (생략)

■이때, 에러발생 : (vscode콘솔창) "Request path contains unescaped characters"
	>> [해결]
	function loadHashtagPostsAPI(tag, lastId) {
  		return axios.get(`/hashtag/${encodeURIComponent(tag)}`);	// tag가 한글 이므로,
								// encodeURIComponent 사용헤주자.
	}

■pages/user.js 에도 SSR 적용시켜 보자. 

□메모: 
(pages/user.js)
const User = ({ id }) => { 		// 현재 이대로 진행중..

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ시작ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
▶▶ pages/profile.js 에도 SSR 적용시켜 보자. ★★★
■ 오류 발생 
Profile.getInitialProps = async (context) => {
    const state = context.store.getState();

    ●① 이 직전에 (_app.js에서) LOAD_USER_REQUEST
    context.store.dispatch({
        type: LOAD_FOLLOWERS_REQUEST,              
        data: state.user.me && state.user.me.id,		// ●③얘네는 null
    });
    context.store.dispatch({
        type: LOAD_FOLLOWINGS_REQUEST,             
        data: state.user.me && state.user.me.id,		// ●③얘네는 null
    });
    context.store.dispatch({
        type: LOAD_USER_POSTS_REQUEST,               
        data: state.user.me && state.user.me.id,		// ●③얘네는 null
    });

    ●② 여기서 LOAD_USER_SUCCESS 되서, me가 생김 
};

■ 해결방법 2가지
- 방법1. LOAD_USER 되고나서 액션3개 실행			-> 너무 느려짐
- 방법2. LOAD_USER 액션포함해서 총 4개 한꺼번에 실행★


▶▶ 방법2 사용해보자. (=꼼수) 
"data가 null이면, 자기 자신이라고 간주한다. "

(sagas/user.js)
■ 액션1 에 대한 saga
function loadFollowersAPI(userId) {
  return axios.get(`/user/${userId || 0}/followers`, {	// null이라고 하면 오류인것 같으니까 편의상 0 넣어주자.
						// 남의 아이디가 대상일 때는 userId가 있을것이다.
						// 하지만, 내 팔로워들 가져오려면 userId는 없다.(=null)(=false)
						// 이때, || 다음으로 넘어가진다. 
    withCredentials: true,
  });
}

...
■ 액션2 에 대한 saga
function loadFollowingsAPI(userId) {			// null은 기본값이 지정이 안됨. 
						// 즉, function loadFollowingsAPI(userId = 0) 이렇게 하면 오류
						// 밑에다가 지정해주자 
  // 서버에 요청을 보내는 부분
  return axios.get(`/user/${userId || 0}/followings`, {	// null이라고 하면 오류인것 같으니까 편의상 0 넣어주자.
    withCredentials: true,
  });
}

■ 액션3 에 대한 saga
(sagas/post.js)
function loadUserPostsAPI(id) {
    return axios.get(`/user/${id || 0}/posts`);		// null이라고 하면 오류인것 같으니까 편의상 0 넣어주자.
}

■ 액션3 에 대한 saga에서 axios요청 보낸 부분을 가보면...
(routes/user.js)
router.get('/:id/posts', async (req, res, next) => {
    try {
      const posts = await db.Post.findAll({
        where: {
          UserId: parseInt(req.params.id, 10) || (req.user && req.user.id) || 0,     // parseInt(req.params.id, 10)가 0 이라면, 
							         	 // || 다음부분 실행 !  (숫자 0은 false 이기 때문)
							         	 // -> req.user에는 현재 내 정보 들어있다. 
          RetweetId: null,                      
        },
      ...
■ 액션1,2 saga에서 axios 요청 보낸 부분도 역시 바꿔주자..

■ 최종 결과 (=백단 cmd 콘솔창을 봐보자)
> 프로필 페이지 이동 & 새로고침 해보기 
> GET /api/user/0/posts 200 22.936 ms - 4573		-> 0 이 잘 들어가 있음을 확인할 수 있다. 

▶질문: parseInt는 왜 필요한가 ?
답변: req.params.id가 문자열이다.    ex) UserId: parseInt(req.params.id, 10)\
	-> 기본적으로는 parseInt안해줘도 되는데, 여기에서는 false로 처리하기 위해 parseInt필요.

<숫자로 바꾸는 이유>
- 의미상으로도 userId는 숫자여야한다.
- || 다음으로 넘어가기 위해
ex)
where: { UserId: parseInt(req.params.id, 10) || ~~~ } 	-> 이런경우, userId가 숫자여야 || 다음으로 넘어갈 수 있다.
	>> Why?
	> [자바스크립트의 특성] : 숫자 0 이면 false,  문자 '0' 은 true
	> parseInt(req.params.id, 10)가 false 여야만 || 다음으로 넘어갈 수 있다. 
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ끝ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

▶불변성을 지키는 추가/삭제 pattern (=immer 안썼을때)
- 추가: 
Posts: [{ id: action.data }, ...state.me.Posts],

- 삭제: 
me: {
   ...state.me,
   Posts: state.me.Posts.filter(v => v.id != action.data),
}


▶'더보기' 구현 - queryString 사용

function loadFollowingsAPI(userId, offset = 0, limit = 3) {
  return axios.get(`/user/${userId || 0}/followings?offset=${offset}&limit=${limit}`, {	// queryString: key-value
    withCredentials: true,
  });
}

router.get('/:id/followings', isLoggedIn, async (req, res, next) => { 
  try {
    ...
    const myFollowings = await user.getFollowings({   
      attributes: ['id', 'nickname'],                 
      limit: parseInt(req.query.limit, 10),			// req.query.OOO
      offset: parseInt(req.query.offset, 10),
    });

▶인피니티 스크롤링 
- 문제 :  offset 쓰면 안됨.   Why? 글 내리는 도중에, 누가 글 써버리면 offset 체계 무너져 버림 -> 게시글 중복해서 가져옴 
- 해결 :  일정길이 이상 스크롤시, 마지막 게시글의 id(=lastId)를 가져와서, (=pages/index.js의 onScroll함수에서 lastId 첫 생성)
	그 id보다 작은 게시글들을 limit만큼 보여준다. (id는 내림차순)
- 팔로워 더보기 역시 lastId로 하는게 안전하다. (스크롤 내리는 중간에 팔로워 추가될 수 있기 때문) 
- sagas/user.js의  function* loadUserPosts 도 바꿔보는것 숙제 ★

- ※ 알아두기: offset은 성능상의 문제도 있기 때문에 잘 안쓴다. 거의다 lastId로 구현 

▶쓰로틀링
(sagas/post.js)
yield throttle(1000, LOAD_MAIN_POSTS_REQUEST, loadMainPosts);	// REQUEST가 호출되고, 1초가 지나기전까지는 
							// 같은 REQUEST가 호출될 수 없다.

▶해시태그 페이지, 다른유저 페이지 에도 인피니티 스크롤+쓰로틀링 똑같이 적용시켜보기(숙제)


▶immer : 불변성을 유지하면서, 가독성은 쉽게 해줌 
-> reducers/post.js에 적용시켜보기 
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
import produce from 'immer';
return produce(state, (draft)) => { ... } ); 	// immer를 쓰면, 더 이상 우리가 불변성을 지켜 줄 필요가 없다.(알아서 해줌)
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

▶saga에서 쓰로틀링 했는데도, 현재 동일한 REQUEST가 두번씩 가고있음.  
- Why? saga는 saga만 담당한다. 리덕스의 액션까지 제어할 수 없다.
- 해결)) 프론트단에서, 조건을 두고, dispatch가 아예 실행도 안 되도록해서, 리덕스 액션 호출 막기 필요 

(pages/index.js)
const countRef = useRef(); 	  		// 보냈던 lastId들 기억하는 배열 
...
        const lastId = mainPosts[mainPosts.length -1].id
        if (!countRef.current.includes(lastId)) { 	// 한번 보냈었던 lastId는 다시 보내지 않도록
          dispatch({
            type: LOAD_MAIN_POSTS_REQUEST,
            lastId: lastId,   
          });
        }
        countRef.current.push(lastId);		// 보낸 lastId 들을 기록
        ...


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ시작ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
▶검색봇 테스트를위해, pages/post.js 작성후, postman으로 localhost:3062/post/32   GET으로 긁어보기 
-> 현재 post.js 본문 태그에서 content랑, 작성자 닉네임, image 등이 잘 뜨는데, 
-> 문제 : 검색엔진이 어떤게 content고, 어떤게 image 인지 모른다. 
-> 해결 : meta태그에 명시를 해줘야 된다. (또는 schema.org 사용 -> 사용법 알아야됨)
-> react-helmet으로 head 태그 조작해주는 방법을 배워보자. 

▶react-helmet으로 head 태그 조작하기 
<Helmet> 태그를 이용해서 정보를 pages/post.js에 작성 -> 이제, 웹페이지 F12에서는 잘 보인다 (http://localhost:3062/post/32)
But. PostMan(=검색봇 시점)에서는 보이지 않는다. -> 그래서, react-helmet도 SSR이 필요하다. 

▶ <react-helmet에 SSR 적용하기>
■순서1. pages폴더에 _document.js(특수파일) 생성&작성 -> Hooks문법 안되고, Class문법 써야됨 
	- But. 아직도 PostMan에 안긁어져와있음. 
■순서2. _app.js부분의 <Head>역시 Helmet으로 변환해주자. 
	-> (_app.js)모든 페이지에 공통되는 <Head>태그를 <Helmet>에 넣는다.
	-> _app.js <Helmet>의 title이 먼저 적용되다가, 하위 컴포넌트에서는 하위컴포넌트의 <Helmet> title로 덮어씌워진다. 
■순서3. (_app.js) import App, { Container } from 'next/app';	-> _app.js의 return()부분을 <Container>로 감싸주자 
■순서4. 
(_document.js) 
const page = context.renderPage((App) => (props) => <App {...props} />);		// App은 _app.js이다.

-> context에서 renderPage()를 위와같이 해줘야 _app.js가 실행된다. (_document.js가 _app.js의 상위 컴포넌트이다.)
■이제, PostMan에서 원하는대로 잘 긁어와진다. 


▶위계관계 (정리)
■순서1. _document.js 에서 _app.js 호출 
■순서2. (_app.js)
/* 다른 컴포넌트들을 호출한다. */
if (Component.getInitialProps) {                        
    pageProps = await Component.getInitialProps(ctx);  
} 
■순서3. (post.js)
Post.getInitialProps = async (context) => {
    // [SSR] dispatch
    context.store.dispatch({
        type: LOAD_POST_REQUEST,
        data: context.query.id,
    });
    return { id: parseInt(context.query.id, 10) };
};

▶이제, PostMan으로 메인페이지(http://localhost:3062/) 들어가보면, _app.js에서 설정했던 <Helmet>이 있는것을 확인 가능
ex)  <meta data-react-helmet="true" name="description" content="NodeBird SNS" /> 

▶og태그 = open graph (스스로 공부해보기)
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ끝ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ


▶styled-components
지금까지 style넣을때 <div>태그안에 inline으로 지저분하게 작성했었음. 유지보수도 힘들었음. 

ex) (components/ImagesZoom.js)
import styled from 'styled-components';	이후, 작업 ㄱㄱ

■가장바깥 태그들만 styled-components로 만들고, 내부는 css선택자로 만들어야, 나중에 변수명 짓기 안힘들어짐 !!
■sc-OOO로 시작하는 이름의 class로, 우리가 지정해준 스타일들을 추가해 준다. 
■현재 검색봇 입장에서 style이 하나도 적용 안되어있음. -> styled-components로 SSR필요 

▶styled-components SSR적용하기 
(각각의 의미를 알려하지 말고, 공식문서에 이렇게 쓰라고 나와있어서 이렇게 쓰는거)

(_document.js)
import { ServerStyleSheet } from 'styled-components';
..
class MyDocument extends Document {
   static getInitialProps(context) {
      const sheet = new ServerStyleSheet();			// sheet 생성
      const page = context.renderPage((App) => (props) => 
	   sheet.collectStyles(<App {...props} />));   		// sheet.collectStyles()로 App(=_app.js)을 감싼다. 
      const styleTags = sheet.getStyleElement();			// styleTags 생성
      return { ...page, helmet: Helmet.renderStatic(), styleTags };	// styleTags 추가
}
...
MyDocument.propTypes = {
    helmet: PropTypes.object.isRequired,
    styleTags: PropTypes.object.isRequired,			// 얘 추가 
};
...
<head {...htmlAttrs}>
    {this.props.styleTags}					// 최종적으로, 이러면 알아서 SSR적용됨 
    {Object.values(helmet).map(el => el.toComponent())}   
</head>

▶테스트)) SSR이 잘 적용됐는지 확인:  PostCard.js 에서 styled-components적용후, 테스트해보기 
(PostCard.js)
...
const CardWrapper = styled.div`
  margin-bottom: 20px;			// 이제, PostMan에서도 이게 잘 뜬다.(=SSR이 잘 되고있다는 뜻)
`;  
...


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ시작ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
▶페이지 바꾸기 : 컴포넌트적으로는 Link, 프로그래밍적으로는 Router로 가능 

■동적 라우팅
(AppLayout.js) 
const onSearch = (value) => {	// 해시태그 검색창 
	Router.push( 
		{ pathname: '/hashtag', query: { tag: value } }, 		// 내부적(프론트)으로는 이 주소로 접근해야되고, 
		`hashtag/${value}`					// 외부적으로는 이 주소로 보인다.
	);					
};

(PostCardContent.js)
<Link 
    href={{ pathname: '/hashtag', query: { tag: v.slice(1) } }} 		// 내부적(프론트)으로는 이 주소로 접근해야되고, 
    as={`/hashtag/${v.slice(1)}`}					// 외부적으로는 이 주소로 보인다.
    key={v}
>

■Link 태그의 href는 [프론트엔드 서버]가 처리합니다. ★★즉, 프론트엔드의 server.js에서 처리합니다.

왜 내부적, 외부적 주소 다르게 해줬을까 ?
-> 실제 동적라우팅 할때, 서버쪽 주소랑 프론트쪽 주소가 다르기 때문에 

(server.js)
/* 해당 태그의 게시물들 가져오기 */
server.get('/hashtag/:tag', (req, res) => {			 // ■외부적주소(=눈으로 보이는주소)
    return app.render(req, res, '/hashtag', { tag: req.params.tag });    // ■내부적주소 : pages/hashtag.js 를 렌더링
                                                                             	 	// query {}를 같이 전달해줘야, 프론트에서 동적인 tag를 캐치 가능 
});

->  pages/hashtag.js	
->  sagas/post.js	
->  back/routes/hashtag ...
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ끝ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

▶F12 콘솔창에 뜨는 오류들 최적화 하기 
■오류 메시지 : Warning: Failed prop type: The prop `pageProps` is marked as required in `NodeBird`, but its value is `undefined`.
■해결 : (_app.js) 에서.. 
NodeBird.propTypes = {
    Component: PropTypes.elementType.isRequired, 
    store: PropTypes.object.isRequired,
    pageProps: PropTypes.object.isRequired,		// 해결방법1) isRequired빼버리거나,
						// 해결방법2) pageProps가 무조건 들어있게 해주면 된다. 
};

해결방법2))
NodeBird.getInitialProps = async (context) => {
	...
	/* 다른 컴포넌트들을 호출한다. */
	if (Component.getInitialProps) {                       
        	pageProps = await Component.getInitialProps(ctx) || {};   		// 여기에  OOOO || {} 로 기본값 설정해주면 항상 존재하게 된다. 
    	} 
    
    	return { pageProps };
};


■오류 메시지 : Warning: Failed prop type: Invalid prop `post.createdAt` of type `string` supplied to `PostCard`, expected `object`.
■해결 : (PostCard.js) 에서..
(1)
PostCard.propTypes = {
    ...
    //createdAt: PropTypes.object,
    createdAt: PropTypes.string,	// string으로 수정 
  }),
};

(2)
return (
    <CardWrapper>
      <Card
        key={+post.createdAt}		// key가 여기 있을 필요가없다. key는 항상 반복문 안에 있어야한다.★ 

추가적으로..))
(pages/index.js) 에서..
return (
      ...
      {/* 게시글 보기 */}
      {mainPosts.map((c) => {
        return (
          <PostCard key={c.id} post={c} />	// key를 고유한 값으로 만들어주자 (id는 고유한 값)




▶폴더구조 구축하기
■components폴더 아래에 ImagesZoom폴더 만들어서, 그 안에 ImagesZoom.js(=index.js로 이름변경할것) + 스타일.js

■components / containers 로 분리 (처음부터 분리해서 작업해야 편리..)
- components 	: ImagesZoom처럼 화면만 표시하는 애들
- containers 	: redux dispatch 하는 애들


▶_error.js (특수파일)를 이용해서, 에러 발생시 페이지에 에러 statusCode 표시해줌. 

▶favicon 적용해보기 
(server.js)
server.use('/', express.static(path.join(__dirname, 'public')))		// 이 한 줄만 넣어주면, favicon생김 



ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ시작ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
▶▶지금까지는, next에서 기본적으로 제공해주는 '웹팩', '바벨' 설정을 써왔음.  
-> 이제는 우리가 이런것들을 커스터마이징 해야, 패키지 간에 덜 최적화된 부분 등을 해결할 수 있음.
-> next.config.js를 생성 (next에 대한 설정을 하는 파일)

■front> npm i @next/bundle-analyzer			// 프론트쪽의 패키지를 분석해준다. ★
	-> 사용법 깃허브 ( https://github.com/vercel/next.js/tree/canary/packages/next-bundle-analyzer )
	-> 여기 나와있는대로 그대로 따라해주자.
(next.config.js)
const withBundleAnalyzer = require('@next/bundle-analyzer')({	// withBundleAnalyzer 생성 
    enabled: process.env.ANALYZE === 'true',
});
module.exports = withBundleAnalyzer({			// withBundleAnalyzer 로 감싸준다. 
    distDir: '.next',
    webpack(config) {
        const prod = process.env.NODE_ENV === 'production'
        return {
            ...config,
            // 기존 설정(config)에 덮어 씌울 부분 
            mode: prod ? 'production' : 'development',
            devtool: prod ? 'hidden-source-map' : 'eval',  	// hidden-source-map : 소스코드 숨기면서 에러시 소스맵 제공
                                                           		// eval: 빠르게 웹팩 적용
        };
    },
});
■front> npm i cross-env			
(cross-env쓰는이유)
(package.json)	
"scripts": {
    "dev": "nodemon",
    "build": "cross-env ANALYZE=true next build",		// 윈도우에서도 ANALYZE=true 명령어 작동하도록 하기위해
    "start": "cross-env NODE_ENV=production next start"		// 윈도우에서도 NODE_ENV=production 명령어 작동하도록 하기위해
  },
■front> npm run build 
Compiled successfully.
 ┌ /
 ├ /_app
 ├ /_document
 ├ /_error
 ├ /hashtag
 ├ /post
 ├ /profile
 ├ /signup
 └ /user
■이제, front/.next/analyze폴더에 client.html, server.html 생성되어있음. 
-> 각각 프론트,백단 웹페이지 구조를 보여줌.  용량(=Parsed Size) 등 확인가능
-> 문제점 : (client.html) 현재 antd의 icon이 대부분의 용량을 차지 하고있음. (=1/3 정도 차지..)	
		-> 검색: antd icon tree shaking(=나무 흔들어서 나뭇잎 떨구기) 가능한지 ? 
		-> 통째로 하나로된 파일이라서, 전문적인 도움없이는 불가능.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ끝ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ시작ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
▶▶tree shaking 예제
■front> npm i moment		// 날짜 패키지 
(PostCard.js)
import moment from 'moment';
..
moment.locale('ko');
..
moment(post.createdAt).format('YYYY.MM.DD.')	
..

■front> npm run build 
-> 확인해보면, moment도 용량이 엄청 크다 !!
-> But. antd icon처럼 하나로 이루어진게 아니라, 잘게 쪼개져 있다. -> 하는법 검색해서 알아내야됨.(moment 깃허브 참조)

■moment 패키지 - tree shaking 하는법 (https://github.com/jmblog/how-to-optimize-momentjs-with-webpack)
(next.config.js)
..
const webpack = require('webpack');
..
const plugins = [
	..
	new webpack.ContextReplacementPlugin(/moment[/\\]locale$/, /^\.\/ko$/),	// 이걸 넣어주면 됨(검색해서 알아냄)
];
return {
	..
	plugins,
};

(Moment.js의 대체제도 있다. : https://github.com/you-dont-need/You-Dont-Need-Momentjs)

■이제, front> npm run build 다시 해보기. 
-> 확연히 줄어든것을 확인할 수 있다.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
※ 참고
(package.json) "prestart": "npm run build", 를 넣어주면, 
	"start"하기전에, "prestart"가 실행되서 bulid를 먼저하게 된후, start를 하게 된다. (=편리)
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

■Tree shaking 의 장점 
- 로딩도 빠르고 모바일 데이터도 아낄 수 있습니다.
- 잘게 쪼개면 웹팩이 실제로 사용하는 모듈만 로딩합니다. 트리쉐이킹이라고 부릅니다.

■antd icon도 Tree shaking 해보자.(=역시나 검색)	-> 딱히 큰 효과는 X
(next.config.js)
return {
	...
	module: {
       	...config.module,
        	rules: [
          		...config.module.rules,
          		{
            		loader: 'webpack-ant-icon-loader',
            		enforce: 'pre',
            		include: [
              			require.resolve('@ant-design/icons/lib/dist'),
            		],
          		},
        	],
      },

추가해준뒤, front> npm i webpack-ant-icon-loader 설치해주기.

-> 효과 X 
-> 그냥.. antd icon말고, 다른것 쓰자..



▶▶gzip으로 압축하기 (매우 효율적)
■front> npm i compression-webpack-plugin  설치하기 

■(next.config.js)
const CompressionPlugin = require('compression-webpack-plugin');
...
if (prod) {     					// 배포 일때만, CompressionPlugin 사용하도록.
            plugins.push(new CompressionPlugin()); 	// CompressionPlugin(): 파일확장자를 .gz로 만들어줌.    ex) main.js.gz
						// 용량을 1/3정도로 줄여서 서버->프론트로 가져올 수 있음.
}
■front> npm run build  해보기
front - .next - server - static - 가장위의 해시값으로 이름된 폴더(빌드할때마다 생기는 폴더) 
				- _app.js아래에 _app.gz가 추가되어있는것을 확인할 수 있다.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ끝ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ시작ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
▶▶최적화 예제1 
- 문제 : 현재 게시글에 '좋아요' 누르면, 아랫 게시글들 까지 리렌더링 되고있다. 
- 해결 : 가장 쉬운방법은 memo로 감싸주는것.★
import React, { useState, useCallback, useEffect, memo } from 'react';
const PostCard = memo( ({ post }) => {	... 
});
■But. 단순 React.memo로는 지금 해결이 안되는 상황!
■Form이 거의 리렌더링의 주범이다.★ Form은 기본적으로 분리를 하고 시작하는것이 좋다. 
-> 댓글 Form부터 분리해보자!

(PostCard.js)
...
{commentFormOpened && (
        <>
          <Form onSubmit={onSubmitComment}>		// 댓글 폼 
            <Form.Item>
              <Input.TextArea rows={4} value={commentText} onChange={onChangeCommentText} />
            </Form.Item>
■containers/CommentForm.js를 생성&작성	-> 이제, 댓글입력시, CommentForm만 리렌더링 되는것 성공!

※ 팁 
mainPosts[mainPosts.length -1].id 					-> 이런거 undefined 에러 뜨면, 
mainPosts[mainPosts.length -1] && mainPosts[mainPosts.length -1].id  	-> 이렇게 보호 연산자를 같이 써주자.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ끝ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ



□현재 버그 : 언팔로우 누르면, 팔로우로 글자가 바로 안바뀜 (반대 경우는 잘 됨)  +  팔로워,팔로잉 목록 삭제시 SPA 안됨 
□해결 : 


▶제로초 질문 Q&A (최적화 예제2 강의)
질문1) useCallback의 두번째인자인 []에 매개변수로 들어온 userId 왜 못넣는가?
답변)
useCallback의 인수는 userId => () => {}, 와 [] 두 개입니다. 
둘이 다른 인수이므로 []에서 userId는 당연히 사용할 수 없습니다(스코프가 다릅니다)

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ버그 찾기 시작ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
질문2) 현재 팔로우했다가 바로 언팔로우 해버리면 오류 발생한다. ★★★★★
답변)
언팔로우할 때 redux에서 팔로잉하고 있던 아이디가 빠지나요? 
UNFOLLOW_SUCCESS부분 리듀서가 구현이 이상한 것 아닐까요?

-> 해결) UNFOLLOW_SUCCESS에서 오타 (me.FollowingList를 me.followingList로 수정했음...)
-> 그래도 해결 안됨 
-> [현재 상황]
(Redux Dev Tools) 		UNFOLLOW_USER_REQUEST   ->   UNFOLLOW_USER_FAILURE
(F12 Network 탭) 		DELETE 200 ok	 /   response: 10 (aa의 아이디)

case UNFOLLOW_USER_FAILURE: { 
            console.log('action.error=', action.error);	// 이걸 한번 찍어봤다..
            break;
}
(F12 콘솔 탭) action.error= TypeError: Cannot read property 'findIndex' of undefined

>> 이제, 의심가는 곳은 진짜 "단 하나".. 제로초님이 말씀하신 reducers 부분...

case UNFOLLOW_USER_SUCCESS: {
            const userIndex1 = draft.me.Followings.findIndex(v => v.id === action.data);
            draft.me.Followings.splice(userIndex1, 1);
            const userIndex2 = draft.me.followingList.findIndex(v => v.id === action.data);
            draft.followingList.splice(userIndex2, 1);
            break;
}

-> 아!.. 드디어 해결했다...

■내 코드
case UNFOLLOW_USER_SUCCESS: {
            const userIndex1 = draft.me.Followings.findIndex(v => v.id === action.data);
            draft.me.Followings.splice(userIndex1, 1);
            const userIndex2 = draft.me.followingList.findIndex(v => v.id === action.data);	// 여기..(눈 크게 뜨고 보자..)
            draft.followingList.splice(userIndex2, 1);
            break;
}

■제로초 코드
case UNFOLLOW_USER_SUCCESS: {
            const index = draft.me.Followings.findIndex(v => v.id === action.data);
            draft.me.Followings.splice(index, 1);
            const index2 = draft.followingList.findIndex(v => v.id === action.data);		// 여기..(눈 크게 뜨고 보자..)
            draft.followingList.splice(index2, 1);
            break;
}

■결국, followingList가 문제였다...

case REMOVE_FOLLOWER_SUCCESS: {
	...
	// me.followerList가 아니다!!!!!!!!!!!!!!!!!! 
            const userIndex2 = draft.followerList.findIndex(v => v.id === action.data);
	...
}
-> 여기도 마찬가지...ㅠㅠ

■정리하자면...
- me.Followings는 말 그대로 db에서 내 객체(=me)에 붙어서 한 몸인 존재이고...
- FollowingList: [] 는 프로필 페이지에서 팔로잉목록 불러올때만 사용하는건데,, 
당연히 이것도 항상 set로 같이 붙어 다녀야, 프로필 페이지에서 FollowingList를 제대로 활용할것이다...

- 지금 보면.. [팔로우 버튼] 누를때에, me.Followings배열에는 추가가 되지만, followingList는 여전히 빈 배열이다.
-> 그렇다면 followingList는 언제 채워질까 ? 
★ 여기가 중요 ★ 
프로필 페이지에서 LOAD_FOLLOWINGS_REQUEST  ->  sagas + reducer  ->  (routes) getFollowings로 Followings배열에 있는것 가져옴   
									->   sagas(=SUCCESS)  -> reducer
(이때 reducer를 보면...)
case LOAD_FOLLOWINGS_SUCCESS: {
            action.data.forEach((f) => {
              draft.followingList.push(f);		// 여기서 최초로, followingList에다가 아까 getFollowings로 가져온 배열 담는다...
            });
            draft.hasMoreFollowing = action.data.length === 3;
            break;
}

■이제서야, me.Followings와 followingList가 구별이 된다.. 
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ버그 찾기 끝ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ



ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ시작ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
▶▶최적화 예제2
문제점 : 현재 팔로우버튼 누르면, 다른Card들까지 리렌더링 되고있다.
-> 가장 편한 해결법은, 문제가 되는 Button부분을 분리해버리는 것이다. 
■(PostCard.js) - 변경 전
...
extra={
          !me || post.User.id === me.id
          ? null
          : me.Followings && me.Followings.find(v => v.id === post.User.id)
            ? <Button onClick={onUnfollow(post.User.id)}>언팔로우</Button>		// 여기를 분리해버리자. 
            : <Button onClick={onFollow(post.User.id)}>팔로우</Button>
        }

■(PostCard.js) - 변경 후
...
extra={<FollowButton post={post} onUnfollow={onUnfollow} onFollow={onFollow} />}

■components/FollowButton.js
작성...

▶But. 현재 리렌더링 되는것들 디버깅 해보면.. (  (8-6)리렌더링 디버깅 결과.png 참조  ) ★★
me 때문 이라는것을 알 수 있음. 콘솔에 찍힌 로그 클릭해보면, 특히 me중에 me.Followings가 계속 바뀌기 때문 ! (=원인)
-> 그러나 우리는 PostCard.js에서 me.Followings를 쓰고 있지않음.
-> 현재 PostCard.js의 코드를 보면, me.id만을 사용중임. 
해결) 
const { me } = useSelector(state => state.user); 			// 이 부분을 ..
const myId = useSelector(state => state.user.me && state.user.me.id); 	// 이렇게 바꿔주고, me로 해놨던것들 전부 myId로 바꿔주자 
								// 즉, me객체를 다 불러오지 말자. 

■components/FollowButton.js
const { me } = useSelector(state => state.user);
...
me.Followings && ...		// 얘만 따로 me.Followings쓰도록 하면 해결 !!

useRef() : 
돔에 직접 접근 
값을 기억하고싶으나, 리렌더링 하고싶지 않을때 
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ끝ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ시작ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
▶▶최적화 예제3
(문제점) 
현재 프로필 페이지에서 [팔로잉 목록 더보기] 누르면, 다른것들도 리렌더링 되버림. 
(해결) 
다른애들한테 영향을 미치는애를 따로 분리를 하세요.

(profile.js)
return (
        <div>
            {/* 닉네임 수정폼 */}
            <NicknameEditForm />

            {/* 팔로잉 목록 */}
            <FollowList 				//  components/FollowList.js
                header="팔로잉 목록"
                hasMore={hasMoreFollowing}
                onClickMore={loadMoreFollowings}
                data={followingList}
                onClickStop={onUnfollow}
            />

            {/* 팔로워 목록 */}
            <FollowList 				//  components/FollowList.js
                header="팔로워 목록"
                hasMore={hasMoreFollower}
                onClickMore={loadMoreFollowers}
                data={followerList}
                onClickStop={onRemoveFollower}
            />
...

▶이제, [팔로잉 목록 더보기] 누르면, 팔로잉 목록 부분만 리렌더링 된다. 
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ끝ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ


▶배포전 마지막 준비(IE, 에러 표시)
front> npm start 를 해보면..
( prestart에서 설정해놨던것에 따라 먼저, build가 된 후에, start가 된다. )
> Ready on http://localhost:3000
	-> 실제 배포 환경 페이지 ! (=엄청 빠르다) (페이지에 prefetch 붙이면 더 빠르다)

※ 개발은 여전히 3062 에서 하고, 최종 결과물 확인만 3000 에서 한다. ★
back> npm run dev	(백단 서버 실행시켜놓은 상태에서..)
http://localhost:3000 접속해보자.

-> IE에서도 접속해보자. (안된다..!)
-> _document.js에 IE도 지원할 수 있게 해주는 하나의 코드를 추가해주자. (=polyfill.io) ★
(_documnet.js)
...
<body {...bodyAttrs}>
                <Main />
                {process.env.NODE_ENV === 'production'
                && <script src="https://polyfill.io/v3/polyfill.min.js?features=es6,es7,es8,es9,NodeList.prototype.forEach&flags=gated" />}
                <NextScript />
</body>
...
-> polyfill.io 공식문서 찾아보자. 
-> features=es6,es7,es8,es9,NodeList.prototype.forEach&flags=gated 는 제로초님이 직접 넣어준 옵션들이다.

-> 이제, 서버를 종료했다가, front > npm start 로 다시 배포용 빌드를 해보자. 
-> 잘된다..! (또한, 로그인 할때, 콘솔창에 에러가 나지 않는다!) ( CSS는 깨진다. -> polyfill로 제어불가.. )


▶배포전 몇가지 설정..
1)
현재 pages/post.js 에서 게시글의 대표 이미지를 보여주고 있는데, 
property: 'og:image', content: singlePost.Images[0] && `${backURL}/${singlePost.Images[0].src}`,
	-> 만약, 이미지가 없을때는 favicon이미지를 대표로 보여주게 변경해보자.
	-> (_app.js)
	-> property: 'og:image', content: `${frontURL}/favicon.ico`,  를 추가해주자. 

2)
현재, 로그인 실패시에, 에러 메세지가 없다.  -> 이거 대체 왜안되냐.. loginErrorReason...



▶제로초 Q&A : useMemo와 memo의 차이점 
- 가장 큰 차이점은 useMemo는 훅(=상태관리, 라이프싸이클)이고 memo는 컴포넌트입니다.
- useMemo는 모든 값을 캐싱(=기억)할 수 있고, memo는 컴포넌트를 감싸서 "props가 바뀌었을 때만 리렌더링 되도록 만듭니다."
- memo는 반복되는 td, tr등을 감싸기도 한다.

▶제로초 Q&A : redux vs contextAPI
- contextAPI에는 비동기 기능을 해주는 게 없습니다. 비동기 기능을 사용하고 싶으면 redux로 가셔야 합니다.
- 아 그러면, contextAPI 는  백엔드(노드JS를 이용한)에서 데이터를 가져와서 하는 용도는 아닌가보네요??
- 네네 프론트에서만 사용하시면 됩니다.

▶제로초 Q&A : 강의에서 만드신  규모의 사이트면 보통 만드는데 얼마나 걸려야 평균인가요 ??
- 저는 지금이면 하루면 만듭니다. 초보자 기준 2주 안에는 하셔야 합니다.

▶TextArea 내용들 줄바꿈 적용해서 보여주기 : <pre>태그 이용
(PostCard.js)
<pre><PostCardContent postData={post.content}/></pre>




=======================
8.9장 ~ 8.17장 실제 AWS에 배포 	-> 못해도 2주 정도 걸릴듯.
=======================
AWS, EC2, lamba, claudia, S3, 도메인 구입, pm2(프로세스 관리도구), http 이해 ... 

비용 Q&A
- AWS 비용: 한달 약 3만원
- ec2 인스턴스가 존재하기만 하면 바로 비용이 나옵니다. ec2 인스턴스를 중지하시거나 종료해야 비용이 나오지 않습니다.


